<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE chapter [
	<!ENTITY % extensions SYSTEM "../../stylesheets/macros.ent" >
	<!ENTITY % DocBookDTD PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
	"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
	<!ENTITY % entities SYSTEM "../../stylesheets/macros-en.ent" >
	%extensions;
	%DocBookDTD;
	%entities;
]>
<chapter id="chap:listener">
	<title>&ucsUDL;
		<indexterm><primary>Directory Listener</primary></indexterm>
		<indexterm><primary>Listener</primary><see>Directory Listener</see></indexterm>
		<indexterm><primary>&ucsUDL;</primary><see>Directory Listener</see></indexterm>
	</title>

	<para>
		Replication of the directory data within a UCS domain is provided by the Univention
		Directory Listener/Notifier mechanism:

		<itemizedlist>
			<listitem><simpara>
					The &ucsUDL; service runs on all UCS systems.
			</simpara></listitem>

			<listitem><simpara>
				On the &ucsPrimaryDN; (and possibly existing &ucsBackupDN; systems) the <emphasis>&ucsUDN;</emphasis> service monitors
				changes in the LDAP directory and makes the selected changes available to the &ucsUDL;
				services on all UCS systems joined into the domain.
			</simpara></listitem>
		</itemizedlist>
	</para>

	<para>
		The active &ucsUDL; instances in the domain connect to a &ucsUDN; service.
		If an LDAP change is performed on the &ucsPrimaryDN; (all other LDAP servers in the domain are read-only), this is registered by the &ucsUDN; and reported to the listener instances.
	</para>

	<para>
		Each &ucsUDL; instance hosts a range of &ucsUDL; modules.
		These modules are shipped by the installed applications; the print server package includes, for example, listener modules which generate the CUPS configuration.
	</para>

	<para>
		&ucsUDL; modules can be used to communicate domain changes to services which are not LDAP-aware.
		The print server CUPS is an example of this: The printer definitions are not read from the LDAP, but instead from the file <filename>/etc/cups/printers.conf</filename>.
		Now, if a printer is saved in the printer management of the &ucsUMC;, it is stored in the LDAP directory.
		This change is detected by the &ucsUDL; module <emphasis>cups-printers</emphasis> and an entry gets added to, modified in or deleted from <filename>/etc/cups/printers.conf</filename> based on the modification in the LDAP directory.
	</para>

	<para>
		By default the Listener loads all modules from the directory <filename class="directory">/usr/lib/univention-directory-listener/system/</filename>.
		Other directories can be specified using the option <option>-m</option> when starting the <command>univention-directory-listener</command> daemon.
	</para>

	<section id="listener:handler">
		<title>Structure of Listener Modules</title>
		<para>
			Listener modules can be implemented using the <link linkend="listener:handler:42">high-level API</link> or the <link linkend="listener:handler:low">low-level API</link>.
			New implementations should be based on the newer high-level API, which is available since <u:erratum release="4.2-3">311</u:erratum>.
		</para>
		<para>
			Each listener module must declare several string constants.
			They are required by the &ucsUDL; to handle each module.
		</para>
		<variablelist>
			<varlistentry>
				<term id="udl:mod:name"><varname>name</varname>: <type>str</type> (required)</term>
				<term><function>get_name()</function> -> <type>str</type></term>
				<listitem>
					<para>
						This name is used to uniquely identify the module.
						This should match with the filename containing this listener module without the <literal>.py</literal> suffix.
						The name is used to keep track of the module state in <filename class="directory">/var/lib/univention-directory-listener/handlers/</filename>.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term id="udl:mod:description"><varname>description</varname>: <type>str</type> (required)</term>
				<term><function>get_description()</function> -> <type>str</type></term>
				<listitem>
					<para>
						A short description.
						It is currently unused and displayed nowhere.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term id="udl:mod:filter"><varname>filter</varname>: <type>str</type> (required)</term>
				<term><function>get_ldap_filter()</function> -> <type>str</type></term>
				<term><varname>ldap_filter</varname>: <type>str</type> (high-level API)</term>
				<listitem>
					<para>
						Defines a LDAP filter which is used to match the objects the listener is interested in.
						This filter is similar to the LDAP search filter as defined in <u:rfc>2254</u:rfc>, but more restricted:
					</para>
					<itemizedlist>
						<listitem><simpara>it is case sensitive</simpara></listitem>
						<listitem><simpara>it only supports equal matches</simpara></listitem>
					</itemizedlist>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term id="udl:mod:attributes"><varname>attributes</varname>: <type>List[str]</type> (optional)</term>
				<term><function>get_attributes()</function> -> <type>List[str]</type></term>
				<listitem>
					<para>
						A Python list of LDAP attribute names which further narrows down the condition under which the listener module gets called.
						By default the module is called on all attribute changes of objects matching the filter.
						If the list is specified, the module is only invoked when at least one of the listed attributes is changed.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term id="udl:mod:modrdn"><varname>modrdn</varname>: <type>str</type> (low-level API, optional)</term>
				<listitem>
					<para>
						Setting this variable to the string <literal>1</literal> changes the signature of the function <function>handler()</function>.
						It receives an additional 4th argument, which specifies the LDAP operation triggering the change.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term id="udl:mod:handle_every_delete"><varname>handle_every_delete</varname>: <type>bool</type> (low-level API, optional)</term>
				<listitem>
					<para>
						The Listener uses its <link linkend="listener:details:cache">cache</link> to keep track of objects, especially their previous values and which modules handles which objects.
						The &ucsUCRV; <envar>listener/cache/filter</envar> can be used to prevent certain objects from being stored in the cache.
						But then the Listener no longer knows which module must be called when such an object is deleted.
						Setting this variable to <literal>True</literal> will make the Listener call the function <function>handler()</function> of this module whenever any object is deleted.
						The function then must use other means to determine itself if the deleted object is of the appropriate type as <varname>old</varname> will be <literal>None</literal>.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term id="udl:mod:priority"><varname>priority</varname>: <type>float</type> (optional)</term>
				<term><function>get_priority()</function> -> <type>float</type></term>
				<listitem>
					<para>
						This variable can be used to explicitly overwrite the default order in which the modules are executed.
						By default modules are executed in random order.
						<filename>replication.py</filename> defaults to <literal>0.0</literal> as it must be executed first, all other modules default to <literal>50.0</literal>.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
		<para>
			For handling changes to matching LDAP objects a <phrase>handler</phrase> must be implemented.
			This function is called for different events:
		</para>
		<itemizedlist>
			<listitem><simpara>
					when the object is first created
			</simpara></listitem>
			<listitem><simpara>
					when attributes of an existing object are changed
			</simpara></listitem>
			<listitem><simpara>
					when the object is moved to a different location within the LDAP tree
			</simpara></listitem>
			<listitem><simpara>
					when the object is finally removed
			</simpara></listitem>
			<listitem><simpara>
					when a LDAP schema change happens
			</simpara></listitem>
		</itemizedlist>
		<para>
			The low-level API requires writing a single function <link linkend="udl:mod:handler"><function>handler()</function></link> to handle all those cases.
			The high-level API already splits this into separate methods <link linkend="udl:mod:create"><function>create()</function></link>, <link linkend="udl:mod:modify"><function>modify()</function></link> and <link linkend="udl:mod:remove"><function>remove()</function></link>, which are easier to overwrite.
		</para>
		<para>
			Each module gets initialized once by calling its function <function>initialize()</function>.
			This state of each module is tracked in a file below <filename class="directory">/var/lib/univention-directory-listener/handlers/</filename>.
		</para>
		<variablelist>
			<varlistentry>
				<term id="udl:mod:initialize"><function>initialize()</function> -> <type>None</type> (optional)</term>
				<listitem>
					<para>
						The function <function>initialize()</function> is called once when the &ucsUDL; loads the module for the first time.
						This is recorded persistently in the file <filename>/var/lib/univention-directory-listener/<replaceable>name</replaceable></filename>, where <varname>name</varname> equals the value from the header.
					</para>
					<para>
						If for whatever reason the listener module should be reset and re-run for all matching objects, the state can be reset by running the command <command>univention-directory-listener-ctrl resync <replaceable>name</replaceable></command>.
						In that case the function <function>initialize()</function> will be called again.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term id="udl:mod:clean"><function>clean()</function> -> <type>None</type> (optional)</term>
				<listitem>
					<para>
						The function <function>clean()</function> is only called when the &ucsUDL; is initialized for the first time or is forced to <quote>re-initialize from scratch</quote> using the  option<option>-g</option>, <option>-i</option>, or <option>-P</option>.
						The function should purge all previously generated files and return the module into a clean state.
						Afterwards the module will be re-initialized by calling the function <function>initialize()</function>.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
		<para>
			For efficiency reasons the API provides two functions, which resumes and suspends modules when no transactions are processed for 15 seconds.
			All modules start in the state <phrase>suspended</phrase>.
			Before a <phrase>suspended</phrase> modules is called to handle a change the function <function>prerun()</function> is called for that module.
			If no transactions happen within a time span of 15 seconds the Listener suspends all active modules by calling the function <function>postrun()</function>.
			This mechanism is most often used to batch changes by collecting multiple changes and applying them only on suspend.
		</para>
		<variablelist>
			<varlistentry>
				<term id="udl:mod:prerun"><function>prerun()</function> -> <type>None</type> (optional)</term>
				<term id="udl:mod:postrun"><function>postrun()</function> -> <type>None</type> (optional)</term>
				<listitem>
					<para>
						For optimization the &ucsUDL; does not keep open an <abbrev>LDAP</abbrev> connection all time.
						Instead the connection is opened once at the beginning of a change and closed only if no new change arrives within 15 seconds.
						The opening is signaled by the invocation of the function <function>prerun()</function> and the closing by <function>postrun()</function>.
					</para>
					<para>
						The function <function>postrun()</function> is most often used to restart services, as restarting a service takes some time and makes the service unavailable during that time.
						It's best practice to use the <function>handler()</function> only to process the stream of changes, set UCR variables or generate new configuration files.
						Restarting associated services should be delayed to the <function>postrun()</function> function.
					</para>
					<warning>
						<para>
							The function <function>postrun()</function> is only called, when no change happens for 15 seconds.
							This is not on a per-module basis, but globally.
							In an ever changing system, where the stream of changes never pauses for 15 seconds, the functions may never be called!
						</para>
					</warning>
				</listitem>
			</varlistentry>
		</variablelist>
	</section>

	<section id="listener:handler:42">
		<title>High-level Listener modules API</title>
		<!--
			../../../management/univention-directory-listener/README.md
			../../../management/univention-directory-listener/examples/listener_module_template.py
			../../../management/univention-directory-listener/examples/complex_handler.py
		-->
		<para>
			&ucsUDL; ships with a template in <u:src>management/univention-directory-listener/examples/listener_module_template.py</u:src>.
			This should be used as a stating point for new modules.
			The more complex example in <u:src>management/univention-directory-listener/examples/complex_handler.py</u:src> can also be used.
		</para>
		<para>
			Alternatively the implementation can start from scratch:
		</para>
		<orderedlist>
			<listitem><simpara>Create a subclass of <classname>univention.listener.ListenerModuleHandler</classname>.</simpara></listitem>
			<listitem><simpara>Add an inner class called <classname>Configuration</classname> which at least has the attributes <property>name</property>, <property>description</property> and <property>ldap_filter</property>.</simpara></listitem>
		</orderedlist>
		<para>
			The inner class <classname>Configuration</classname> is used to configure global module settings.
			For most properties a corresponding method exists, which just returns the value of the property by default.
			The methods can be overwritten if values should be computed once on module load.
		</para>
		<variablelist>
			<varlistentry>
				<term><function>get_name()</function> -> <type>str</type> (required)</term>
				<term><varname>name</varname>: <type>str</type></term>
				<listitem>
					<simpara>The internal name of the handler; see <link linkend="udl:mod:name">name</link>.</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><function>get_description()</function> -> <type>str</type> (required)</term>
				<term><varname>description</varname>: <type>str</type></term>
				<listitem>
					<simpara>A descriptive text; see <link linkend="udl:mod:description">description</link>.</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><function>get_ldap_filter()</function> -> <type>str</type> (required)</term>
				<term><varname>ldap_filter</varname>: <type>str</type></term>
				<listitem>
					<simpara>The LDAP filter string; see <link linkend="udl:mod:filter">filter</link>.</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><function>get_attributes()</function> -> <type>List[str]</type> (optional)</term>
				<term><varname>attributes</varname>: <type>List[str]</type></term>
				<listitem>
					<simpara>The list of attributes, for when they are changed, the module is called; see <link linkend="udl:mod:attributes">attributes</link>.</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><function>get_priority()</function> -> <type>float</type> (optional)</term>
				<term><varname>priority</varname>: <type>float</type></term>
				<listitem>
					<simpara>The priority for ordering; see <link linkend="udl:mod:priority">priority</link>.</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><function>get_listener_module_instance()</function> -> <type>ListenerModuleHandler</type></term>
				<listitem>
					<simpara>This creates an instance of the handler module and returns it.</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><function>get_listener_module_class()</function> -> <type>[ListenerModuleHandler]</type> (optional)</term>
				<term><varname>listener_module_class</varname>: <type>[ListenerModuleHandler]</type></term>
				<listitem>
					<simpara>Class that implements the module. Will be set automatically by the handlers meta-class.</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><function>get_active()</function> -> <type>bool</type></term>
				<listitem>
					<para>
						This returns the value of the &ucsUCRV; <envar>listener/module/<replaceable>name</replaceable>/deactivate</envar> as a boolean.
						Setting the variable to <literal>False</literal> will prevent the module from being called for all changes.
					</para>
					<note>
						<simpara>
							Re-enabling the module will not result in the module being called for all previously missed changes.
							For this the module must be fully resynchronized.
						</simpara>
					</note>
				</listitem>
			</varlistentry>
		</variablelist>
		<para>
			The handler itself should inherit from <classname>univention.listener.ListenerModuleHandler</classname> and then overwrite some methods to provide its own implementation:
		</para>
		<variablelist>
			<varlistentry>
				<term id="udl:mod:create"><function>create(dn: str, new: Mapping[str, Sequence[bytes])</function> -> <type>None</type></term>
				<listitem>
					<simpara>Called when a new object was created.</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term id="udl:mod:modify"><function>modify(dn: str, new: Mapping[str, Sequence[bytes], old: Mapping[str, Sequence[bytes], old_dn: Optional[str])</function> -> <type>None</type></term>
				<listitem>
					<simpara>Called when a new object was modified or moved. In case of a move <varname>old_dn</varname> is set. During a move attributes may be modified, too.</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term id="udl:mod:remove"><function>remove(dn: str, old: Mapping[str, Sequence[bytes])</function> -> <type>None</type></term>
				<listitem>
					<simpara>Called when a new object was deleted.</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><function>initialize()</function> -> <type>None</type></term>
				<listitem>
					<simpara>Called once when the module is not initialized yet.</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><function>clean()</function> -> <type>None</type></term>
				<listitem>
					<simpara>Called once before a module is resynchronized.</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><function>pre_run()</function> -> <type>None</type></term>
				<listitem>
					<simpara>Called once each time before a batch of transactions is processed.</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><function>post_run()</function> -> <type>None</type></term>
				<listitem>
					<simpara>Called once each time after a batch of transactions is processed.</simpara>
				</listitem>
			</varlistentry>
		</variablelist>
		<para>
			In addition to those handler functions the class also provides several convenience functions:
		</para>
		<variablelist>
			<varlistentry>
				<term><function>as_root()</function> -> <type>None</type></term>
				<listitem>
					<simpara>
						A context manager to temporarily change the effective UID of the current to 0.
						Also see <function>listener.SetUID()</function> described in <xref linkend="listener:details:credentials"/>.
					</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><function>diff(old: Mapping[str, Sequence[bytes]], new: Mapping[str, Sequence[bytes]], keys: Optional[Iterable[str]], ignore_metadata: bool)</function> -> <type>Dict[str, Tuple[Optional[Sequence[bytes]], Optional[Sequence[bytes]]]]</type></term>
				<listitem>
					<simpara>Calculate difference between old and new LDAP attributes. By default all attributes are compared, but this can be limited by naming them via <varname>keys</varname>. By default <phrase>operational attributes</phrase> are excluded unless <varname>ignore_metadata</varname> is enabled.</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><function>error_handler(dn: str, old: Mapping[str, Sequence[bytes]], new: Mapping[str, Sequence[bytes]], command: str, exc_type: Optional[Type[BaseExcepion]], exc_value: Optional[BaseExcepion], exc_traceback: Optional[types.TracebackType])</function> -> <type>None</type></term>
				<listitem>
					<simpara>
						This method will be called for unhandled exceptions in <methodname>create</methodname>/<methodname>modify</methodname>/<methodname>remove</methodname>.
						By default it logs the exception and re-raises it.
					</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><varname>lo</varname>: <type>univention.uldap.access</type></term>
				<listitem>
					<simpara>This property returns a LDAP connection object to access the local LDAP server.</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><varname>po</varname>: <type>univention.uldap.position</type></term>
				<listitem>
					<simpara>This property returns a LDAP position object for the LDAP base DN.</simpara>
				</listitem>
			</varlistentry>
		</variablelist>
		<para>
			Any instance also has the following variables:
		</para>
		<variablelist>
			<varlistentry>
				<term><varname>logger</varname>: <type>logging.Logger</type></term>
				<listitem>
					<simpara>An instance of <classname>logging.Logger</classname>.</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><varname>ucr</varname>: <type>univention.config_registry.ConfigRegistry</type></term>
				<listitem>
					<simpara>A reference to the shared instance <varname>listener.configRegistry</varname>.</simpara>
				</listitem>
			</varlistentry>
		</variablelist>
	</section>

	<section id="listener:handler:low">
		<title>Low-level Listener module</title>

		<para>
			Each Listener module is implemented as a plain Python module.
			The required variables and functions must be declared at the module level.
		</para>
		<programlisting language="python"><![CDATA[
name : str = "module_name"
description : str = "Module description"
filter : str = "(objectClass=*)"
attributes : List[str] = ["objectClass"]
modrdn : str = "1"
		]]></programlisting>
		<para>
			On top of the description in <xref linkend="listener:handler"/> the following extra  notes apply:
		</para>
		<variablelist>
			<varlistentry>
				<term><varname>filter</varname>: <type>str</type> (required)</term>
				<listitem>
					<note>
						<para>
							The name <literal>filter</literal> has the drawback that it shadows the Python built-in function <function>filter()</function>, but its use has historical reasons.
							If that function is required for implementing the listener module, an alias-reference may be defined before overwriting the name or it may be explicitly accessed via the Python <literal>__builtin__</literal> module.
						</para>
					</note>
				</listitem>
			</varlistentry>
		</variablelist>
		<para>
			In addition to the static strings a module must implement several functions.
			They are called in different situations of the live-cycle of the module.
		</para>
		<programlisting language="python"><![CDATA[
def initialize() -> None:
  pass
def handler(
  dn: str,
  new: Optional[Mapping[str, Sequence[bytes]]],
  old: Optional[Mapping[str, Sequence[bytes]]],
  command: str = '',
) -> None:
  pass
def clean() -> None:
  pass
def prerun() -> None:
  pass
def postrun() -> None:
  pass
def setdata(key: str, value: str) -> None:
  pass
		]]></programlisting>
		<variablelist>
			<varlistentry>
				<term id="udl:mod:handler"><function>handler(dn: str, new: Optional[Mapping[str, Sequence[bytes]]], old: Optional[Mapping[str, Sequence[bytes]]], command: str = '')</function> -> <type>None</type> (required)</term>
				<listitem>
					<para>
						This function is called for each change matching the <varname>filter</varname> and <varname>attributes</varname> as declared in the header of the module.
						The distinguished name (<abbrev>dn</abbrev>) of the object is supplied as the first argument <varname>dn</varname>.
					</para>
					<para>
						Depending on the type of modification, <varname>old</varname> and <varname>new</varname> may each independently either be <literal>None</literal> or reference a Python dictionary of lists.
						Each list represents one of the multi-valued attributes of the object.
						The &ucsUDL; uses a local cache to store the values of each object as it has seen most recently.
						This cache is used to supply the values for <varname>old</varname>, while the values in <varname>new</varname> are those retrieved from that LDAP directory service which is running on the same server as the &ucsUDN; (&ucsPrimaryDN; or &ucsBackupDN; servers in the domain).
					</para>
					<para>
						If and only if the global <varname>modrdn</varname> setting is enabled, <varname>command</varname> is passed as a fourth argument.
						It contains a single letter, which indicates the type of modification.
						This can be used to distinguish an <firstterm>modrdn</firstterm> operation from a delete operation followed by a create operation.
					</para>
					<variablelist>
						<varlistentry>
							<term><literal>m</literal> (modify)</term>
							<listitem>
								<para>
									Signals a modify operation, where an existing object is changed.
									<varname>old</varname> contains a copy of the previously cached values and <varname>new</varname> contains the new values as retrieved from the LDAP directory service.
								</para>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><literal>a</literal> (add)</term>
							<listitem>
								<para>
									Signals the addition of a new object.
									<varname>old</varname> is <literal>None</literal> and <varname>new</varname> contains the values of the added object.
								</para>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><literal>d</literal> (delete)</term>
							<listitem>
								<para>
									Signals the removal of a previously existing object.
									<varname>old</varname> contains a copy of the previously cached values, while <varname>new</varname> is <literal>None</literal>.
								</para>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><literal>r</literal> (rename: modification of distinguished name via <literal>modrdn</literal>)</term>
							<listitem>
								<para>
									Signals a change in the distinguished name, which may be caused by renaming a object or moving the object from one container into another.
									The module is called with this command instead of the <emphasis>delete</emphasis> command, so that modules can recognize this special case and avoid deletion of local data associated with the object.
									The module will be called again with the <emphasis>add</emphasis> command just after the <emphasis>modrdn</emphasis> command, where it should process the rename or move operation.
									Each module is responsible for keeping track of the rename-case by internally storing the previous distinguished name during the <emphasis>modrdn</emphasis> phase of this two phased operation.
								</para>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><literal>n</literal> (new or schema change)</term>
							<listitem>
								<para>This command can signal two changes:</para>
								<itemizedlist>
									<listitem>
										<simpara>If <varname>dn</varname> is <literal>cn=Subschema</literal>, it signals that a schema change occurred.</simpara>
									</listitem>
									<listitem>
										<simpara>All other cases signal the initialization of a new object, which should be handled just like a normal <function>add</function> operation.</simpara>
									</listitem>
								</itemizedlist>
							</listitem>
						</varlistentry>
					</variablelist>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term id="udl:mod:setdata"><function>setdata(key: str, value: str)</function> -> <type>None</type> (optional)</term>
				<listitem>
					<para>
						This function is called up to four times by the &ucsUDL; main process to pass configuration data into the modules.
						The following <varname>key</varname>s are supplied in the following order:
					</para>
					<variablelist>
						<varlistentry>
							<term><literal>basedn</literal></term>
							<listitem><simpara>The base distinguished name the &ucsUDL; is using.</simpara></listitem>
						</varlistentry>
						<varlistentry>
							<term><literal>binddn</literal></term>
							<listitem><simpara>The distinguished name the &ucsUDL; is using to authenticate to the <abbrev>LDAP</abbrev> server (via <literal>simple bind</literal>).</simpara></listitem>
						</varlistentry>
						<varlistentry>
							<term><literal>bindpw</literal></term>
							<listitem><simpara>The password the &ucsUDL; is using to authenticate to the <abbrev>LDAP</abbrev> server.</simpara></listitem>
						</varlistentry>
						<varlistentry>
							<term><literal>ldapserver</literal></term>
							<listitem><simpara>The hostname of the <abbrev>LDAP</abbrev> server the &ucsUDL; is currently reading from.</simpara></listitem>
						</varlistentry>
					</variablelist>
					<note>
						<para>
							It's strongly recommended to avoid initiating LDAP modifications from a listener module.
							This potentially creates a complex modification dynamic, considering that a module may run on several systems in parallel at their own timing.
						</para>
					</note>
				</listitem>
			</varlistentry>
		</variablelist>
	</section>

	<section id="listener:example">
		<title>Listener Tasks and Examples
			<indexterm><primary>Directory Listener</primary><secondary>Example module</secondary></indexterm>
		</title>
		<para>
			All changes trigger a call to the function <function>handle()</function>.
			For simplicity and readability it is advisable to delegate the different change types to different sub-functions.
		</para>

		<section id="listener:example:api">
			<title>Listener API Example</title>
			<para>
				The following boilerplate code uses the newer listener API.
			</para>
			<para>
				Source code: <u:src>management/univention-directory-listener/examples/listener_module_template.py</u:src>
			</para>
			<programlisting language="python"><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../management/univention-directory-listener/examples/listener_module_template.py" parse="text"/></programlisting>
		</section>

		<section id="listener:example:simple">
			<title>Basic Example</title>
			<para>
				The following boilerplate code delegates each change type to a separate function.
				It does not handle renames and moves explicitly, but only as the removal of the object at the old <abbrev>dn</abbrev> and the following addition at the new <abbrev>dn</abbrev>.
			</para>
			<para>
				Source code: <u:src>doc/developer-reference/listener/simple.py</u:src>
			</para>
			<programlisting language="python"><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="simple.py" parse="text"/></programlisting>
		</section>

		<section id="listener:example:modrdn">
			<title>Rename and Move
				<indexterm><primary>Directory Listener</primary><secondary>modrdn</secondary></indexterm>
			</title>
			<para>
				In case rename and move actions should be handled separately, the following code may be used:
			</para>
			<para>
				Source code: <u:src>doc/developer-reference/listener/modrdn.py</u:src>
			</para>
			<programlisting language="python"><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="modrdn.py" parse="text"/></programlisting>
			<warning>
				<para>
					Please be aware that tracking the two subsequent calls for <literal>modrdn</literal> in memory might cause duplicates, in case the &ucsUDL; is terminated while such an operation is performed.
					If this is critical, the state should be stored persistently into a temporary file.
				</para>
			</warning>
		</section>

		<section id="listener:example:user">
			<title>Full Example with Packaging</title>
			<para>
				The following example shows a listener module, which logs all changes to users into the file <filename>/root/UserList.txt</filename>.
			</para>
			<para>
				Source code: <u:src>doc/developer-reference/listener/printusers/</u:src>
			</para>
			<programlisting language="python"><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="printusers/printusers.py" parse="text"/></programlisting>
			<para>
				Some comments on the code:
			</para>
			<itemizedlist>
				<listitem>
					<simpara>
						The <abbrev>LDAP</abbrev> filter is specifically chosen to only match user objects, but not computer objects, which have a uid characteristically terminated by a <literal>$</literal>-sign.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						The <varname>attribute</varname> filter further restricts the module to only trigger on changes to the numeric and symbolic user identifier and the last name of the user.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						To test this run a command like <command>tail -f /root/UserList.txt &amp;</command>.
						Then create a new user or modify the <emphasis>lastname</emphasis> of an existing one to trigger the module.
					</simpara>
				</listitem>
			</itemizedlist>
			<para>
				For packaging the following files are required:
			</para>
			<variablelist>
				<varlistentry>
					<term><filename>debian/printusers.install</filename></term>
					<listitem>
						<para>
							The module should be installed into the directory <filename class="directory">/usr/lib/univention-directory-listener/system/</filename>.
						</para>
						<programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="printusers/debian/printusers.install" parse="text"/></programlisting>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><filename>debian/printusers.postinst</filename></term>
					<listitem>
						<para>
							The &ucsUDL; must be restarted after package installation and removal:
						</para>
						<programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="printusers/debian/printusers.postinst" parse="text"/></programlisting>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><filename>debian/printusers.postrm</filename></term>
					<listitem>
						<programlisting><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="printusers/debian/printusers.postrm" parse="text"/></programlisting>
					</listitem>
				</varlistentry>
			</variablelist>
		</section>

		<section id="listener:example:setdata">
			<title>A Little Bit more Object Oriented</title>
			<para>
				For larger modules it might be preferable to use a more object oriented design like the following example, which logs referential integrity violations into a file.
			</para>
			<para>
				Source code: <u:src>doc/developer-reference/listener/obj.py</u:src>
			</para>
			<programlisting language="python"><xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="obj.py" parse="text"/></programlisting>
		</section>
	</section>

	<section id="listener:details">
		<title>Technical Details
			<indexterm><primary>Directory Listener</primary><secondary>Debug</secondary></indexterm>
		</title>

		<!--
		<section id="listener:details:packaging">
			<title>Packaging details</title>
			<itemizedlist>
				<listitem><simpara>The module should be installed into the directory <filename class="directory">/usr/lib/univention-directory-listener/system/</filename>.</simpara></listitem>
				<listitem><simpara>The process <command>univention-directory-listener</command> must be restarted by the <filename>postinst</filename> and <filename>postrm</filename> Debian package maintainer scripts.</simpara></listitem>
			</itemizedlist>
		</section>
		-->

		<section id="listener:details:credentials">
			<title>User-ID and Credentials
				<indexterm><primary>Directory Listener</primary><secondary>Credentials</secondary></indexterm>
			</title>
			<para>
				The listener runs with the effective permissions of the user <literal>listener</literal>.
				If <literal>root</literal>-privileges are required, <function>listener.SetUID()</function> can be used as a context manager or method wrapper to switch the effective UID.
			</para>
		<programlisting language="python"><![CDATA[
from listener import SetUID

@SetUID()
def prerun() -> None:
			pass

def postrun() -> None:
	with SetUID(0):
			pass
		]]></programlisting>
		</section>

		<section id="listener:details:cache">
			<title>Internal Cache
				<indexterm><primary>Directory Listener</primary><secondary>Cache</secondary></indexterm>
			</title>
			<para>
				The directory <filename class="directory">/var/lib/univention-directory-listener/</filename> contains several files:
			</para>
			<variablelist>
				<varlistentry>
					<term><filename>cache/cache.mdb</filename>, <filename>cache/lock.mdb</filename></term>
					<listitem>
						<para>
							Starting with UCS 4.2 the LMDB cache database contains a copy of all objects and their attributes.
							It is used to supply the old values supplied through the <varname>old</varname> parameter, when the function <function>handle()</function> is called.
						</para>
						<para>
							The cache is also used to keep track, for which object which module was called.
							This is required when a new module is added, which is invoked for all already existing objects when the &ucsUDL; is restarted.
						</para>
						<para>
							On domain controllers the cache could be replaced by doing a query to the local LDAP server, before the new values are written into it.
							But &ucsManagedNode; do not have a local LDAP server, so there the cache is needed.
							Also note that the cache keeps track of the associated listener modules, which is not available from the LDAP.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><filename>cache.lock</filename></term>
					<listitem>
						<para>
							Starting with UCS 4.2 this file is used to detect if a listener opened the cache database.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><filename>cache.db</filename>, <filename>cache.db.lock</filename></term>
					<listitem>
						<para>
							Before UCS 4.2 the <abbrev>BDB</abbrev> cache file contained a copy of all objects and their attributes.
							With the update to UCS 4.2 it gets converted into an <abbrev>LMDB</abbrev> database.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><filename>notifier_id</filename></term>
					<listitem>
						<para>
							This file contains the last <firstterm>notifier ID</firstterm> read from the &ucsUDN;.
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><filename class="directory">handlers/</filename></term>
					<listitem>
						<para>
							For each module the directory contains a text file consisting of a single number.
							The name of the file is derived from the values of the variable <varname>name</varname> as defined in each listener module.
							The number is to be interpreted as a bit-field of <constant>HANDLER_INITIALIZED=0x1</constant> and <constant>HANDLER_READY=0x2</constant>.
							If both bits are set, it indicates that the module was successfully initialized by running the function <function>initialize()</function>.
							Otherwise both bits are unset.
						</para>
					</listitem>
				</varlistentry>
			</variablelist>
			<para>
				The package <package>univention-directory-listener</package> contains several commands useful for controlling and debugging problems with the &ucsUDL;.
				This can be useful for debugging listener cache inconsistencies.
			</para>

			<section id="listener:commands:ctrl">
				<title><command>univention-directory-listener-ctrl</command></title>
				<para>
					The command <command>univention-directory-listener-ctrl status</command> shows the status of the Listener.
					This includes the transaction from the &ucsPrimaryDN; in comparison to the last processes transaction.
					It also shows a list of all installed modules and their status.
				</para>
				<para>
					The command <command>univention-directory-listener-ctrl resync <replaceable>name</replaceable></command> can be used to reset and re-initialize a module.
					It stops any currently running listener process, removes the state file for the specified module and starts the listener process again.
					This forces the functions <function>clean()</function> and <function>initialize()</function> to be called one after the other.
				</para>
			</section>

			<section id="listener:commands:dump">
				<title><command>univention-directory-listener-dump</command></title>
				<para>
					The command <command>univention-directory-listener-dump</command> can be used to dump the cache file <filename>/var/lib/univention-directory-listener/cache.db</filename>.
					The &ucsUDL; must be stopped first by invoking <command>systemctl stop univention-directory-listener</command>.
					It outputs the cache in format compatible to the <abbrev>LDAP</abbrev> Data Interchange Format (<abbrev>LDIF</abbrev>).
				</para>
			</section>

			<section id="listener:commands:verify">
				<title><command>univention-directory-listener-verify</command>
					<indexterm><primary>Directory Listener</primary><secondary>Verify</secondary></indexterm>
				</title>
				<para>
					The command <command>univention-directory-listener-verify</command> can be used to compare the content of the cache file <filename>/var/lib/univention-directory-listener/cache.db</filename> to the content of an <abbrev>LDAP</abbrev> server.
					The &ucsUDL; must be stopped first by invoking <command>systemctl stop univention-directory-listener</command>.
					<abbrev>LDAP</abbrev> credentials must be supplied at the command line.
					For example, the following command would use the machine password:
					<programlisting language="sh">
univention-directory-listener-verify \
	-b "$(ucr get ldap/base)" \
	-D "$(ucr get ldap/hostdn)" \
	-w "$(cat /etc/machine.secret)"
					</programlisting>
				</para>
			</section>

			<section id="listener:commands:getnid">
				<title><command>get_notifier_id.py</command>
					<indexterm><primary>Directory Listener</primary><secondary>Notifier ID</secondary></indexterm>
				</title>
				<para>
					The command <command>/usr/share/univention-directory-listener/get_notifier_id.py</command> can be used to get the latest ID from the notifier.
					This is done by querying the &ucsUDN; running on the <abbrev>LDAP</abbrev> server configured through the &ucsUCRV; <envar>ldap/master</envar>.
					The returned value should be equal to the value currently stored in the file <filename>/var/lib/univention-directory-listener/notifier_id</filename>.
					Otherwise the &ucsUDL; might still be processing a transaction or it might indicate a problem with the &ucsUDL;
				</para>
			</section>
		</section>

		<section id="listener:details:internal">
			<title>Internal working</title>
			<para>
				The Listener/Notifier mechanism is used to trigger arbitrary actions when changes occur in the <abbrev>LDAP</abbrev> directory service.
				In addition to the <abbrev>LDAP</abbrev> server <command>slapd</command> it consists of two other services:
				The &ucsUDN; service runs next to the <abbrev>LDAP</abbrev> server and broadcasts change information to interested parties.
				The &ucsUDL; service listens for those notifications, downloads the changes and runs listener modules performing arbitrary local actions like storing the data in a local <abbrev>LDAP</abbrev> server for replication or generating configuration files for non-<abbrev>LDAP</abbrev>-aware local services.
			</para>
			<figure id="listener:schema"><title>Listener/Notifier mechanism</title>
				<graphic scalefit="1" width="80%" fileref="illustrations50/ListenerNotifier.png"/>
			</figure>
			<para>
				On startup the listener connects to the notifier and opens a persistent <abbrev>TCP</abbrev> connection to port 6669.
				The host can be configured through several &ucsUCRV;s:
			</para>
			<itemizedlist>
				<listitem>
					<simpara>
						If <envar>notifier/server</envar> is explicitly set, only that named host is used.
						In addition the &ucsUCRV; <envar>notifier/server/port</envar> can be used to explicitly configure a different <abbrev>TCP</abbrev> port other then 6669.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Otherwise on the &ucsPrimaryDN; and on all &ucsBackupDN;s, only the host named in <envar>ldap/master</envar> is used.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Otherwise on all other system roles a host is chosen randomly from the combined list of names in <envar>ldap/master</envar> and <envar>ldap/backup</envar><footnote><simpara>This list of &ucsBackupDN;s stored in the &ucsUCRV; <envar>ldap/backup</envar> is automatically updated by the listener module <filename>ldap_server.py</filename>.</simpara></footnote>.
					</simpara>
				</listitem>
			</itemizedlist>
			<para>
				The following steps occur on changes:
			</para>
			<procedure id="listener:procedure">
				<title>Listener/Notifier procedure</title>
				<step>
					<para>
						An <abbrev>LDAP</abbrev> object is modified on the &ucsPrimaryDN;.
						Changes initiated on all other system roles are re-directed to the &ucsPrimaryDN;.
					</para>
				</step>
				<step>
					<para>
						The UCS-specific overlay-module <filename>translog</filename> assigns the next transaction number.
						It uses the file <filename>/var/lib/univention-ldap/last_id</filename> to keep track of the last transaction number.
						As a fallback the transaction number of the last entry from the file <filename>/var/lib/univention-ldap/listener/listener</filename> or <filename>/var/lib/univention-ldap/notify/transaction</filename> is used.
						The module appends the transaction <abbrev>ID</abbrev>, <abbrev>DN</abbrev> and change type to the file <filename>/var/lib/univention-ldap/listener/listener</filename><footnote><simpara>Referred to as <varname>FILE_NAME_LISTENER</varname>, <varname>TRANSACTION_FILE</varname> in the source code</simpara></footnote>.
					</para>
				</step>
				<step>
					<para>
						The &ucsUDN; watches that file and waits until it becomes non empty.
						The file is then renamed to <filename>/var/lib/univention-ldap/listener/listener.priv</filename><footnote><simpara>Referred to as <varname>FILE_NAME_NOTIFIER_PRIV</varname></simpara></footnote> and the original files is re-created empty.
						The transactions from the renamed file are processed line-by-line and are appended to the file <filename>/var/lib/univention-ldap/notify/transaction</filename><footnote><simpara>Referred to as <varname>FILE_NAME_TF</varname> in the source code</simpara></footnote>, including the <abbrev>DN</abbrev>.
						Since protocol version 3 the notifier also stores the same information within the LDAP server by creating the entry <uri>reqSession=<replaceable>ID</replaceable>,cn=translog</uri>.
						After successful processing the renamed file is deleted.
						For efficient access by transaction ID the index <filename>transaction.index</filename> is updated.
					</para>
				</step>
				<step>
					<para>
						All listeners get notified of the new transaction.
						Before <u:erratum release="4.3-3">427</u:erratum> the information already included the latest transaction <abbrev>ID</abbrev>, <abbrev>DN</abbrev> and the change type.
						With protocol version 3 only the transaction <abbrev>ID</abbrev> is included.
					</para>
				</step>
				<step>
					<para>
						Each listener opens a connection to the LDAP server running on the UCS system which was used to query the Notifier.
						With protocol version 3 the listener first queries the LDAP server for the missing <abbrev>DN</abbrev> and change type information by retrieving the entry <uri>reqSession=<replaceable>ID</replaceable>,cn=translog</uri>.
						With that it retrieves the latest state of the object identified through the <abbrev>DN</abbrev>.
						If access is blocked, for example, by <firstterm>selective replication</firstterm>, the change is handled as a delete operation instead.
					</para>
				</step>
				<step>
					<para>
						The old state of the object is fetched from the local listener cache located in <filename class="directory">/var/lib/univention-directory-listener/cache/</filename>.
					</para>
				</step>
				<step>
					<para>
						For each module it is checked, if either the old or new state of the object matches the <varname>filter</varname> and <varname>attributes</varname> specified in the corresponding Python variables.
						If not, the module is skipped.
						<filename>replication.py</filename> is always called first to guarantee that the data is available from the local LDAP server for all subsequent modules.
					</para>
				</step>
				<step>
					<para>
						If the function <function>prerun()</function> of module was not called yet, this is done to signal the start of changes.
					</para>
				</step>
				<step>
					<para>
						The function <function>handler()</function> specified in the module is called, passing in the <abbrev>DN</abbrev> and the old and new state.
					</para>
				</step>
				<step>
					<para>
						The main listener process updates its cache with the new values, including the names of the modules which successfully handled that object.
						This guarantees that the module is still called, even when the filter criteria would no longer match the object after modification.
					</para>
				</step>
				<step>
					<para>
						On a &ucsBackupDN; the &ucsUDL; writes the transaction data to the file <filename>/var/lib/univention-ldap/listener/listener</filename><footnote><simpara>Referred to as <varname>FILE_NAME_LISTENER</varname>, <varname>TRANSACTION_FILE</varname> in the source code</simpara></footnote> to allow the &ucsUDN; to be cascaded.
						This is configured internally with the option <option>-o</option> of <command>univention-directory-listener</command> and is done for load balancing and failover reasons.
					</para>
				</step>
				<step>
					<para>
						The transaction ID is written into the local file <filename>/var/lib/univention-directory-listener/notifier_id</filename>.
					</para>
				</step>
				<step>
					<para>
						After 15 seconds of inactivity the function <function>postrun()</function> is invoked for all prepared modules.
						This signals a break in the stream of changes and requests the module to release its resources and/or start pending operations.
					</para>
				</step>
			</procedure>
		</section>
		<section id="listener:python-migration">
			<title>Python 3 Migration
				<indexterm><primary>Python 3</primary><secondary>Migration</secondary></indexterm>
			</title>
			<para>
				Since UCS 5.0 the &ucsUDL; uses Python 3 to execute listener modules.
		</para>
		<para>
				For a successful migration all functions must be migrated to work with Python 3.
				There is no change in the module variables (<varname>name</varname>, <varname>description</varname>, <varname>filter</varname>, ...) necessary.
		</para>
		<para>
				The data structure of the arguments <varname>new</varname> and <varname>old</varname> given to the <function>handler()</function> function now explicitly differentiates between byte strings (<type>bytes</type>) and unicode strings (<type>str</type>).
				The dictionary keys are strings while the LDAP attribute values are list of byte strings:
				<programlisting language="python"><![CDATA[
{
  'associatedDomain': [b'example.net'],
  'krb5RealmName': [b'EXAMPLE.NET'],
  'dc': [b'example'],
  'nisDomain': [b'example.net'],
  'objectClass': [
    b'top',
    b'krb5Realm',
    b'univentionPolicyReference',
    b'nisDomainObject',
    b'domainRelatedObject',
    b'domain',
    b'univentionBase',
    b'univentionObject'
  ],
  'univentionObjectType': [b'container/dc'],
}
				]]></programlisting>
		</para>
		<para>
				While in UCS 4 <function>handler()</function> typically looked like:
				<programlisting language="python"><![CDATA[
def handler(
    dn,   # type: str,
    new,  # type: Optional[Mapping[str, Sequence[str]]]
    old,  # type: Optional[Mapping[str, Sequence[str]]]
):  # type: (...) -> None
    if new and 'myObjectClass' in new.get('objectClass', []):
        value = new['myAttribute'][0]
        ...
				]]></programlisting>
		</para>
		<para>
			In UCS 5 it would look like:
			<programlisting language="python"><![CDATA[
def handler(
    dn: str,
    new: Optional[Mapping[str, Sequence[bytes]]],
    old: Optional[Mapping[str, Sequence[bytes]]],
) -> None:
    if new and b'myObjectClass' in new.get('objectClass', []):
        value = new['myAttribute'][0].decode('UTF-8')
        ...
			]]></programlisting>
			</para>
		</section>
	</section>

</chapter>
<!-- vim:set ft=docbk ts=2 sw=2 noet: -->
