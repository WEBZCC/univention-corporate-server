#!/usr/bin/python2.7
# -*- coding: utf-8 -*-
#
# Copyright 2021 Univention GmbH
#
# https://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <https://www.gnu.org/licenses/>.
#

from __future__ import print_function

import os
import re
from hashlib import md5
from glob import glob
import subprocess
from argparse import ArgumentParser

from univention.ldap_cache.cache import get_cache

listener_template = '''#!/usr/bin/python2.7
from univention.ldap_cache.listener_module import LdapCacheHandler

name = {}

class QueryHandler(LdapCacheHandler):
    class Configuration(LdapCacheHandler.Configuration):
        name = {}
        def get_description(self):
            return 'Automatically created listener module for the univention-group-membership-member cache ({})'
        def get_ldap_filter(self):
            return {}
        def get_attributes(self):
            return {}
'''


def _md5sum(value):
    m = md5()
    m.update(value)
    return m.hexdigest()


def rebuild(args):
    get_cache().rebuild(args.cache_name or None)


def create_listener_modules(args):
    listener_dir = '/usr/lib/univention-directory-listener/system/'
    existing_listeners = set(glob(os.path.join(listener_dir, 'ldap-cache-*')))
    for query, (_caches, attrs) in get_cache().get_queries().items():
        attrs.discard('dn')
        attrs.discard('entryUUID')
        listener_name = 'ldap-cache-%s' % _md5sum(query)
        fname = os.path.join(listener_dir, '%s.py' % listener_name)
        existing_listeners.discard(fname)
        print('Writing', fname, 'for', query)
        with open(fname, 'w') as fd:
            fd.write(listener_template.format(repr(listener_name), repr(listener_name), ', '.join([cache.__class__.__name__ for cache in _caches]), repr(query), repr(sorted(attrs))))
    for fname in existing_listeners:
        print('Removing', fname)
        os.unlink(fname)
    subprocess.call(['service', 'univention-directory-listener', 'restart'])


def list_caches(args):
    caches = get_cache()
    for name, cache in caches._caches.items():
        if cache.single_value:
            print(name, '- stores one value per key')
        else:
            print(name, '- may store multiple values per key')
        print(' The following objects store data:')
        for shard in cache.shards:
            print('  ', shard.ldap_filter)
            print('    ', shard.key, '=>', shard.value)


def query(args):
    caches = get_cache()
    cache = caches.get_sub_cache(args.cache_name)
    if not cache:
        print('No cache named', args.cache_name)
        return
    data = cache.load()
    regex = None
    if args.pattern:
        try:
            regex = re.compile(args.pattern)
        except re.error:
            print('Broken pattern')
            return
    for key in sorted(data):
        if regex is None or regex.search(key):
            print(key, '=>', data[key])


def main():
    usage = '%(prog)s'
    description = 'The LDAP cache stores some portions of the LDAP database so that it can be accessed fast and reliably.'
    parser = ArgumentParser(usage=usage, description=description)
    subparsers = parser.add_subparsers(description='type %(prog)s <action> --help for further help and possible arguments', metavar='action')

    subparser = subparsers.add_parser('query', description='Queries a sub cache and shows the value(s). Mainly for test purposes, this tool is not meant for real applications', help='Query the cache')
    subparser.add_argument('cache_name', help='The name of the sub cache. See "list"')
    subparser.add_argument('pattern', nargs='?', help='Queries the key with this regexp')
    subparser.set_defaults(func=query)

    subparser = subparsers.add_parser('list', description='Lists all sub caches of the cache. Each sub cache may be fed from multiple sources', help='List all parts of the cache')
    subparser.set_defaults(func=list_caches)

    subparser = subparsers.add_parser('rebuild', description='Rebuild the cache completely, retrieve the objects and overwrite all previous data', help='Rebuild the cache')
    subparser.add_argument('cache_name', nargs='*', help='The cache consists of different parts. You can only rebuild certain parts of the cache. See "list"')
    subparser.set_defaults(func=rebuild)

    subparser = subparsers.add_parser('create-listener-modules', description='Automatically creates listener modules that will eventually fill the cache (and removes unnecessary); restarts the univention-directory-listener. May be needed after shards are added to /removed from the cache', help='Create listener modules')
    subparser.set_defaults(func=create_listener_modules)

    args = parser.parse_args()
    args.func(args)


if __name__ == '__main__':
    main()
